<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>Conway's Game of Life in TypeScript and Dart</title>
    <meta name="description" content="Conway's Game of Life in TypeScript and Dart">
    <meta name="author" content="Ezward">

    <link href="../ezward.css" rel="stylesheet"></link>  
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="life.css?v=1.0">
    <script src="life.ts.js"></script>

</head>
<body>
    <div class="masthead">
        <p>Ezward on GitHub</p>
        <a href="../index.html" class="home">home</a>
    </div>
    
    <main class="main-content">
        <!-- Use h1 for article name: should match <title/> for SEO -->
        <h1>Conway's Game of Life in TypeScript and Dart</h1>
        
        <aside>
            <span>Contents</span>
            <nav>
                <a href="#introduction">The Game</a>
                <a href="#world">The World</a>
                <a href="#algorithm">The Algorithm</a>
                <a href="#motivation">Motivation</a>
                <a href="#javascript">Why not JavaScript?</a>
                <a href="#differences">Differences between TypeScript and Dart</a>
                <a href="#project">The Project</a>
            </nav>
        </aside>
        
        <section id="introduction">
            <a name="introduction"><h3>The Game</h3></a>
            <p>Conway's Life is not really a game, it is a cellular automata that, to our eye, simulates the evolution of a population.  So there are no 'moves' that are made.  Instead, the board (or the world) is populated, then the rules are applied to create a new population.  This is done over and over again so that the population evolves.  Even though the rules are simple, the result can be amazingly complex and interesting.</p>
            <h4>The rules of Life</h4>
            <ul>
                <li>Any live individual with fewer than two live neighbors dies, as if caused by under-population.</li>
                <li>Any live individual with two or three live neighbors lives on to the next generation.</li>
                <li>Any live individual with more than three live neighbors dies, as if by overcrowding.</li>
                <li>Any dead individual with exactly three live neighbors becomes a live individual, as if by reproduction.</li>
            </ul>
            
            <!-- an instance of the simulation -->
            <div id="stage-container">
                <canvas id="stage-canvas">Oops, your browser does not support Html5 Canvas.</canvas>  
            </div>

            <p>The fun part is watching as the population evolves; as you watch the world animate you will understand why Conway called this Life.  For a more detailed and visual explanation, see this <a href="https://class.coursera.org/modelthinking/lecture/22?s=e" target="_blank">video</a> from the University of Michigan.  If you liked that video, you may want to see the <a href="https://class.coursera.org/modelthinking/lecture/23?s=e" target="_blank">next one</a> in the series which goes into depth on 1D Cellular Automata.  If you are really interested in Cellular Automata, here is an <a href="http://plato.stanford.edu/entries/cellular-automata/"  target="_blank">entry</a> in the Stanford Encyclopedia of Philosophy that talks about 1D Cellular Automata, the Game of Life (2D Cellular Automata) and their significance to the study of complexity and emergent behavior.
                
        </section>
        
        <section>
            <h3>Data Structures</h3>
            <section>
                <a name="world"><h4>The World</h4></a>
                <p>Life is 'played' on a rectangular field, which we can call the world.  Each (x,y) location in the world can be thought of as a place that an individual occupies.  Sometimes this is called a cell; the cellular part of cellular automata.  An individual may be alive or dead.  The alive individuals make up a population.</p>
                <p>The world is created with a set number of rows and columns.  At construction, an individual is allocated for each (x,y) location.  Each individual also has a list of it's neighboring individuals, which we build after all the individuals have been created.  Each individual has 8 neighbors; think of a tick-tack-toe board with an 'o' in the middle and x's in all the other spots - the x's are the neighbors.  The neighbor lists are constructed in such a way that that the rectangular world is treated as a torus; the top edge is continuous with the bottom edge and the left edge is continuous with the right edge.   If we did not do this, then individuals at the edges would not have the same number of neighbors as the individuals in the center and so the rules for calculating the next generation would break down at the edges.</p>
                <aside>A <a href="http://en.wikipedia.org/wiki/Torus">torus</a> looks like a donut or a bagel.  Would you rather live on a donut or a bagel?</aside>
            </section>
            <section>
                <h4>The Population</h4>
                <p>The most important part of Life is how it changes from generation to generation.  That is handled with a population.  A population is a list of living individuals in a world.  Initially, the program sets individuals into the population using their (x,y) position in the world.  After this initial population is created, the next generation can be calculation use the Population.nextGeneration() method.  That will apply the rules of Life to the current population to calculate the set of alive individuals.  In so doing, it also records which individuals from the current population survived, which died and which individuals were newly born into the new generation.</p>
                <aside>Although it is uncommon, a world can have more than one population.  The populations are distinct and do not interact.</aside>
            </section>
            <section>
                <h4>Drawing</h4>
                <p>Of course, we want to be able to watch all of these changes; that's the fun part.  To draw the population, we use a renderer. Formally, the renderer is an interface the separates the details of drawing from the details of the world, the population and the individuals.  This is an important part of the design; it allows the population to be drawn using any technology or library.  The drawing code simply implements the Renderer.renderIndividual() method and passes the resulting renderer to Population.render().  Population.render() does two things; it first erases the previous generation, then draws the new generation by calling Renderer.renderIndividual() for all Individuals whose state changes (either by dying or being born).  If we continually loop, creating a new generation and drawing it on each iteration, then we can animate the evolution of the population.</p>
            </section>
        </section>
        
        <section>
            <a name="algorithm"><h3>The Algorithm</h3></a>
            <p>A very straightforward way to implement the rules of life would be to visit each (x,y) location in the world and then, at each location, 'ask' all 8 neighbors if they are alive and apply the rules to figure out if that location is born, survives, or dies.  Let's think about how much work this is.  If we have a 10 x 10 world, then we have 100 locations.  So we visit each location, that is 100 locations, then at each location, we visit each neighbor, so that is another 8x100 or 800 locations.  So for a 100 location world, we make 900 location visits.  So the work is 9 times the number of locations.</p>
            <p>Let's think bigger; how about a 1000 x 1000 World?  That's 1,000,000 locations.  So, we know that we need to visit each location and it's 8 neighbors, so we will need to make 9,000,000 visits to create each generation.  As you can see, that is a lot of work.  That is especially problematic if you want to see the population animate as it evolves.  We are doing so much work to create the next generation that he animation will be very slow and unsatisfying.</p>
            <section>
                <h4>A Faster Way</h4>
                <p>The good news is that we can do a lot better by recognizing a couple of things.  First, only live individuals and their immediate neighbors are important in the next generation.  This is because the only way to stay alive or become alive is to have live neighbors, so the live individuals are the important ones.  Second, we can see that once Life progresses past the initial population, then the number of live individuals is much smaller than the number of dead individuals.  In fact, most of the world becomes a vast array of dead individuals and most of those dead individuals have only dead individuals for neighbors.  Because of the rules of Life, we know that a dead individual with all dead neighbors stays dead (there are no zombies in Conway's Life).  So the key to speeding up the evolution of the population is to focus on live individuals and their neighbors and ignore everything else.  Another way to put this is that we should focus on the population rather than the whole world.</p>
                <p>The algorithm that we will use does a couple things to speed things up.  First, we keep a list of live individuals and rather than visit every location we only visit live individuals and their direct neighbors. Next, rather than visit a location and 'asking' how many live neighbors it as, we use the list of live individuals and then tell their neighbors they have a live neighbor.  The neighbor then keeps track of whether it should be alive or dead as it's live neighbors check in.</p>
                <p>For each live individual, we visit it's 8 neighbors to tell each of them that they have a live neighbor.  The work we have to do is still 9xN, but now N is the number of live individuals, which is a small subset of the entire world.  Those locations that are not alive and have no live neighbors, which is most locations, are never visited; they take no work.</p>
            </section>
        </section>
        
        <section>
            <a name="motivation"><h3>Motivation</h3></a>
            <p>You can find the project <a href="https://github.com/Ezward/Typescript-Life">here</a>.  I created this project for a few reasons.  First, I love the web and I wanted to find a way to program it that works for me.  For this reason, I wanted to compare TypeScript with Dart.  Second, I wanted to use a new tool chain (to me).  Third, I like both cellular automata and the canvas element.  So I thought I would put this all together.</p>
            <p>The project's <a href="https://github.com/Ezward/Typescript-Life">readme</a> has more information how to build the applications.  There is a Typescript version and an equivalent Dart version.  Each of them provide a World class, a Population class and an Renderer interface.  Each also implements a Renderer that draws on a canvas element.  Finally, each has a Main that sets up the World and the Population, then animates the change in generations.  You will see in the source that there is basically no UI; going to the page simply runs a full screen life simulation starting with a randomized population.  In later versions, I will all a little ui to allow the simulation to be paused, restarted and reset.</p>
            <section>
                <a name="javascript"><h4>Why not JavaScript?</h4></a>
                <p>While I often write JavaScript, I seldom enjoy it.  I grew up on Pascal, C, C++ and then Java.  So I like strongly typed, well structured languages.  Beyond the lack of types, I find a lot of things in JavaScript that make it harder than it needs to be to structure code in a concise, readable way.  Of course, those that grew up with JavaScript (JavaScript natives) will likely disagree because these things are natural for them (like strong typing is for me), so I in no way am saying that JavaScript is bad.  I'm simply saying that it doesn't work for me.  For instance;</p>
                <ul>
                    <li><strong>Prototypical inheritance</strong><br/>
                        Prototypical inheritance works.  That being said, it has two problems.  First, it is very verbose.  Second, because it is a runtime construct, the creation of a class is procedural code rather than a declarative construct.    There are a number of libraries that can help with this, they mitigate but do not eliminate the problem (and they can be incompatible with one another).  When C++ was in it's infancy, it was implemented with a slow, kludgy preprocessor which make build times unrealistic and make debugging a pain in the ass.  But object orientation was cool.  So I built a set of macros and practices that allowed me to build up an object with data and methods using a standard C compiler.  A class was built up at runtime with a struct that had properties and methods (function pointers).  Inheritance was also done at runtime using a hash table hierarchy.  It was prototypical inheritance implemented in C.  It worked.  It was verbose, but it worked.  But when C++ compilers finally came around, I found that declaring Classes was much, much better than building them at runtime. Prototypical inheritance is at the core of how JavaScript works, so if you don't like that then you need to look elsewhere for your programming language (which is what this project is about).
                    </li>
                    <li><strong>this may be this or that</strong><br/>
                        The issue with 'this' in JavaScript can generally be handled by capturing a function's 'this' in a closure, then referencing that in code.  It works.  It is verbose.  It is kludgy.  So you need to hold you nose and write that boilerplate.
                    </li>
                    <li><strong>Lack of formal packaging/name-spacing in the language</strong><br/>
                        Namespaces and modules are also runtime constructs in JavaScript.  Deeply nested namespaces also have a runtime cost.  There are competing formats for handling modules and they are incompatible.  Module can have a runtime cost unless you run a build step to concatenate your code.  All of this is based on convention; there is no language support for declarative namespaces and modularization.
                    </li>
                </ul>  
                <p>So, I am motivated to write for the browser, but I really want a language other than JavaScript.  Things are pretty good in that regard just about now.  There is a lot of work on compile-to-JavaScript languages.  Some are designed to use a pre-existing language in the browser (<a href="http://www.gwtproject.org/">GWT:Java</a>, <a href="http://leaningtech.com/cheerp/">Cheerp:C++</a>).  Others are attempts at improving JavaScript (<a href="http://www.typescriptlang.org/">Typescript</a>, <a href="http://coffeescript.org/">CoffeeScript</a>).  Finally, some others are attempts at creating greenfield languages for the web (<a href="https://www.dartlang.org/">Dart</a>).</p>
            </section>
        </section>

        <section>
            <a name="differences"><h3>Differences between TypeScript and Dart</h3></a>
            <p>The public api treats each location in the world as an (x,y) coordinate.  The Individual object at each (x,y) location does not need to be part of the public api.  In fact, it should not be part of the public API because that would allow users of the library to construct Individuals; there is no reason to construct Individuals and it is potentially harmful, so we want to prevent it.  The problem is that the World class has a method called _getIndividualXY() that returns an Individual.  That method is used by the Population class, so it needs to be visible within the library, but not visible to users of the library.  This was accomplished differently in TypeScript than in Dart.</p>
            <p>In Dart, it was as simple as making the Individual class hidden by prefixing it with an underscore. In Dart, this makes the class (or method or property) private to the library.  That is, it cannot be seen outside of the library, but it is visible to everything in the library.  This turned out to be perfect for my case.  Of course, each place that it is used needs to use the underscored name, but that is part of the Dart system that I have actually adopted in my other programming because it makes it clear at the point of usage that it is private.</p>
            <p> In TypeScript, I had to use a lot more code and the results are not entirely satisfactory.  TypeScript includes the ability to add a 'private' modifier to a class or method or property.  So my first attempt was to make both the Individual class and the _getIndividualXY() method private.  That did not compile because be when private is applied to a class method, the method becomes private to just that class and cannot be seen by the rest of the library.  There is currently no way to create a 'library' private method with TypeScript.  So, because _getIndividualXY() must be public, then it's return value, which is an Individual, must be public.  So the only other alternative was to make Individual so that it could not be constructed outside of the library.  I did this by creating a public interface type that exposed methods to get important values, but not to set them.  This exposed another weakness; Typescript does not allow get/set in interfaces.  What I wanted to do was to create an interface that says, "You can read the value of x, you can read the value of y, etc." and use getter syntax to implement that.  However, Typescript does not allow getter syntax in interfaces, so I was forced to implement these as functions.</p>
            <p>The 'protected' keyword will be implemented in a near-future release of Typescript, which will eliminate the need for the public interface because we can make _getIndividualXY() protected.  However, I still prefer the Dart method as it handles most common cases very simply.  Also, using the underscore in a name, effectively codifying common usage, makes private visibility clear not only where the class (or method or property) is declared, but also where it is used.</p>
            <p>Here is an <a href="http://lumpofcode.blogspot.com/2012/10/typescript-dart-google-web-toolkit-and.html">article</a> I wrote a while back comparing Dart, TypeScript and GWT and their ability to integrate with JavaScript (spoiler, TypeScript is really good, GWT is good, Dart is not good.) and how to handle 'this' in TypeScript.</p>
        </section>
        <section>
            <a name="project"><h3>The Project</h3></a>
            <p>The project can be found <a href="https://github.com/Ezward/Typescript-Life">here</a>.</p>
            <p>Here are some of the tools I used (beyond TypeScript and Dart):</p>
            <ul>
                <li><a href="http://brackets.io/">Brackets</a> editor<br/>
                    I really like brackets.  When combined with Node/Grunt, it works like a very lightweight, cross-platform IDE (sans refactoring support).  I tried straight text editors with syntax highlighting, but the simple UI that Brackets exposes for navigating files makes this work very well.  I worked in both Windows and Mac and the whole toolchain performed without a hitch in both environments.
                </li>
                <li><a href="http://nodejs.org/">NodeJs</a> and <a href="http://gruntjs.com/">GruntJs</a><br/>
                    I tried gulp first.  But the going in issue that motivated this project is that I don't enjoy writing JavaScript.  Gulp scripts are basically functional-style JavaScript.  I found it hard going.  As soon I switched to Grunt, things got very, very simple.  Grunt scripts are primarily declarative JSON, so I found them very easy to understand.  The Node package manager (NPM) is very easy to use.  There are a ton of plug-ins for Node and Grunt that make automatic building very simple.  This was a big win.
                </li>
                <li><a href="http://lesscss.org/">Less</a> (actually not much less)<br/>
                    I actually have basically no CSS in the project so far; the UI is just a full-screen canvas that I draw to.  So less is kind of use-less in this project.  However, the build system is working.  It was easy to setup.
                </li>
            </ul>
        </section>
        <script>
        // start the life simulation
        var theStage = document.getElementById('stage-canvas');
        var theRunner = new main.LifeRunner(theStage);
        theRunner.magnification = 2;

        //
        // make it so we can start and stop by just touching the stage canvas
        //
        theStage.onclick = function(event) {
            if(theRunner.running) {
                theRunner.stop();
            } else {
                theRunner.start();
            }
        }
        theStage.ondblclick = function(event) {
            theRunner.reset().start();
        }
        theRunner.reset().start();
        </script>
    </main>
</body>
</html>